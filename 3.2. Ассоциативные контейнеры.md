# [3.2. Ассоциативные контейнеры](https://education.yandex.ru/handbook/cpp/article/associative-containers)
## A. Встречалось ли число раньше?
На вход подаётся последовательность целых чисел. Для каждого числа выведите в отдельной строке слово YES, если это число ранее встречалось в последовательности, и NO, если не встречалось.  

**Формат ввода**  
Вводится список чисел. Все числа списка находятся на одной строке и разделены пробелом. Каждое число представимо типом int.  

**Формат вывода**  
Выведите ответ на задачу.  

---
```c++
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> numbers;
    int number;

    while (std::cin >> number) {
        if (!numbers.insert(number).second) {
            std::cout << "YES\n";
        }
        else {
            std::cout << "NO\n";
        }
    }
}
```

## B. Общие буквы
Вам даны слова. Выведите в алфавитном порядке список общих букв всех слов.  

**Формат ввода**  
На вход поступают слова (по одному в строке), состоящие из маленьких латинских букв алфавита. Длина слов не превосходит 100 символов, а количество слов не превосходит 1000.  

**Формат вывода**  
Выведите в алфавитном порядке без пробелов список букв, которые присутствуют в каждом слове.  

---
```c++
#include <iostream>
#include <map>
#include <set>

int main() {
	std::map<char, int> m;
	std::string word;
	int count = 0;

	while (std::cin >> word) {
		std::set<char> l(word.begin(), word.end());
		for (const char& i : l) {
			++m[i];
		}

		++count;
	}

	for (const auto& [i, v] : m) {
		if (v == count) {
			std::cout << i;
		}
	}
}
```

## C. Файловая система
Дан список всех файлов в некоторой файловой системе. Необходимо вывести все непустые директории этой файловой системы в лексикографическом порядке.  

Гарантируется, что все пути начинаются от корня файловой системы. Все пути состоят из слешей (/), латинских символов, цифр и точек. Два слеша никогда не стоят подряд.  

**Формат ввода**  
На вход подаются строки, описывающие пути ко всем файлам в системе. Каждый путь содержится в отдельной строке. Число строк не превосходит 10000.  

**Формат вывода**  
Выведите все непустые директории в этой файловой системе в лексикографическом порядке. Каждый путь должен начинаться со слеша и заканчиваться слешом.  

---
```c++
#include <iostream>
#include <set>
#include <string>

int main() {
	std::set<std::string> paths;
    std::string s;
	while (std::cin >> s) {
		for (size_t i = 0; i != s.size(); ++i) {
			if (s[i] == '/') {
				paths.insert(s.substr(0, i + 1));
			}
		}
	}

	for (const auto& i : paths) {
		std::cout << i << std::endl;
	}
}

```

## D. Предметный указатель
Профессор написал научную книгу и составил для неё предметный указатель. Это список ключевых слов, для каждого из которых указана страница, на которой это слово встречается. Теперь профессор хочет для каждой страницы выписать в алфавитном порядке все ключевые слова, которые на эту страницу попали (если такие вообще есть). Помогите профессору решить эту задачу.  

**Формат ввода**  
Сначала задано натуральное число n, не превосходящее 1000 — количество слов, которое требуется обработать. Далее идут n строк. В каждой строке сначала записано ключевое слово. Затем идёт натуральное число, также не превосходящее 1000, — номер страницы. Ключевые слова состоят из латинских букв, не бывают пустыми и по длине не превосходят 16 символов. Слова в списке, конечно, могут повторяться.  

**Формат вывода**  
Выпишите в порядке возрастания все страницы, на которых присутствуют ключевые слова. После каждого номера страницы через пробел выпишите в алфавитном порядке сами эти слова. Если на какой-то странице слово встретилось несколько раз, то повторять его не нужно. Завершающего пробела в конце строк быть не должно.  



---
```c++
#include <iostream>
#include <map>
#include <set>
#include <string>

int main() {
    std::map<int, std::set<std::string>> m;

    int n;
    std::cin >> n;
    while (n) {
        std::string word;
        int page;
        std::cin >> word >> page;
        m[page].insert(word);
        --n;
    }

    for (const auto& [page, words] : m) {
        std::cout << page;
        for (const auto& word : words) {
            std::cout << " " << word;
        }
        std::cout << "\n";
    }
}
```

## E. Символьные n-граммы
Будем называть символьной n-граммой последовательность из n последовательно идущих символов в одном слове в тексте. Для данного числа n подсчитайте суммарное количество каждой n-граммы в тексте.  

**Формат ввода**  
В первой строке заданы два числа: m — число слов в тексте (от 1 до 100000) и n — длина n-граммы (от 1 до 5). Далее идет m слов. Можно считать, что слова отделены пробелами или переносами строк. Обработку пунктуации и регистра реализовывать не нужно. Читайте слова просто через std::cin >> word.  

**Формат вывода**  
Выведите все n-граммы, отсортированные по убыванию частоты, а в случае равных частот — лексикографически (по алфавиту). Для каждой n-граммы напечатайте также её частоту (смотрите формат в примере).  

---
```c++
#include <algorithm>
#include <iostream>
#include <string>
#include <tuple>
#include <unordered_map>
#include <vector>

int main() {
	size_t n, m;
	std::unordered_map<std::string, int> um;
	std::cin >> m >> n;
	for (size_t i = 0; i != m; ++i) {
		std::string word;
		std::cin >> word;
		for (size_t s = n; s <= word.size(); ++s) {
				++um[word.substr(s - n, n)];
		}
	}

	std::vector<std::pair<std::string, int>> v(um.begin(), um.end());
	std::sort(
		v.begin(),
		v.end(),
		[](const auto& p1, const auto& p2) {
			return std::tie(p2.second, p1.first) < std::tie(p1.second, p2.first);
		}
	);

	for (const auto& [i, v] : v) {
		std::cout << i << " - " << v << std::endl;
	}

	return 0;
}
```
